<html>
<head>
	<title>XML.com: Using Expat</title>
        <script language="javascript" src="/common.js"></script>
</head>
<body>

<a href="http://www.xml.com/"><img src="/images/xml-logo130.jpg" alt="XML.com" width="130" height="57" border="0" hspace="0" vspace="0"></a>&nbsp;

<br clear="all" />
&nbsp;<font face="verdana,arial,helvetica" size="1">Published on <b><a href="http://xml.com/">XML.com</a></b>&nbsp;<a href="/pub/a/1999/09/expat/index.html">http://www.xml.com/pub/a/1999/09/expat/index.html</a><br />
<a href="/pub/a/admin/printhelp.html">See this</a> if you're having trouble printing code examples</font>
<p>
&nbsp;</p>
<font face="verdana,arial,helvetica">


<!-- ISI_LISTEN_START -->
<span class=ISI_MESSAGE><!--  This article is brought to you by XML.com, your source for all XML news.  --></span>  



<font size="3"><b>Using Expat</b></font><br />
<font size="1"><b>By</b> Clark Cooper<br />
September 01, 1999</font></font>
<!--CS_PAGE_BREAK--><!-- Copyright 1999 Clark Cooper <coopercc@netheaven.com>     All rights reserved.     This is free software. You may distribute or modify according to     the terms of the Perl Artistic license --><br><h3>What is expat?</h3><p>Expat is a library, written in C, for parsing XML documents. It's theunderlying XML parser for the open source Mozilla project, perl'sXML::Parser, and other open-source XML parsers. As demonstrated in my<a href="/pub/a/Benchmark/article.html">benchmark article</a>, it's very fast. It also sets a highstandard for reliability, robustness and correctness.</p><p>This library is the creation of James Clark, who's also given usgroff (an nroff look-alike), Jade (an implemention of ISO's DSSSL stylesheetlanguage for SGML), XP (a Java XML parser package), and XT (a Java XSL engine).James was also the technical lead on the XML Working Group at W3 that producedthe XML specification. Many of these packages are available from<a href="ftp://ftp.jclark.com/pub">ftp://ftp.jclark.com/pub</a>, including<a href="ftp://ftp.jclark.com/pub/xml/expat.zip">expat</a>.There's also a <a href="ftp://ftp.jclark.com/pub/test/expat.zip">test version</a>, which has newer features, but which may not be as robust as thenon-test version.This article is based on a test version, Version 19990709.</p><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td><p class="secondary">

<!--CS_PAGE_INDEX--></p></td><td><p class="secondary" align="right"><a href="<!--CS_NEXT_REF-->"> 
</a></p></td></tr></table>



<!--CS_PAGE_BREAK--><p>

<!--CS_PAGE_INDEX--></p>


<!-- Copyright 1999 Clark Cooper <coopercc@netheaven.com>     All rights reserved.     This is free software. You may distribute or modify according to     the terms of the Perl Artistic license --><h3>Overview of Expat</h3><p>Expat is a stream-oriented parser. You register callback (or handler) functions with the parser and then start feeding it the document.As the parser recognizes parts ofthe document, it will call the appropriate handler for that part (if you'veregistered one). The document is fed to the parser in pieces, so you canstart parsing before you have the whole document. This also allows you toparse really huge documents that won't fit into memory.</p><p>Expat can be intimidating due to the many kinds of handlers and optionsyou can set. But you only need to learn four functions in order to do 80%of what you'll want to do with it:</p><dl><dt><code>XML_ParserCreate</code></dt>  <dd>Create a new parser object.</dd><br /><br/><dt><code>XML_SetElementHandler</code></dt>  <dd>Set handlers for start and end tags.</dd><br /><br /><dt><code>XML_SetCharacterDataHandler</code></dt>  <dd>Set handler for text.</dd><br /><br /><dt><code>XML_Parse</code></dt>  <dd>Pass a buffer full of document to the parser</dd></dl><p>These functions and others are described in the<a href="/pub/a/1999/09/expat/reference.html">reference</a> part of this article. The referencesection also describes in detail the parameters passed to the differenttypes of handlers.</p><p>This <a href="/1999/09/expat/src/src.zip">Zip file</a> contains the Makefile andsource code for examples used in this article.</p><p>Let's look at a very simple example program that only uses three of the abovefunctions. (It doesn't need to set a character handler.) The program<a href="/1999/09/expat/src/outline.c">outline.c</a>prints an element outline, indenting child elements to distinguish them fromthe parent element that contains them. The start handler does all the work.It prints two indenting spaces for every level of ancestor elements, thenit prints the element and attribute information. Finally it increments theglobal Depth variable.</p><p><!--<div class="eg">--><pre>int Depth;voidstart(void *data, const char *el, const char **attr) {  int i;  for (i = 0; i &lt; Depth; i++)    printf("  ");  printf("%s", el);  for (i = 0; attr[i]; i += 2) {    printf(" %s='%s'", attr[i], attr[i + 1]);  }  printf("\n");  Depth++;}  /* End of start handler */</pre><!--</div>--></p><p>The end tag simply does the bookkeeping work of decrementing the Depth.<!--<div class="eg">--><pre>voidend(void *data, const char *el) {  Depth--;}  /* End of end handler */</pre><!--</div>--></p><p>After creating the parser, the main program just has the job ofshoveling the document to the parser so that it can do its work.</p><h3>Building expat</h3><p>One of the problems with using expat is that isn't packaged as a library.Instead there are four separate object files that you have to link intoyour application. The<a href="/1999/09/expat/src/Makefile">Makefile</a> that builds the sample applications in thisarticle can be used as a template.</p><h3>Compile time conditionals</h3><p>There are a few compiletime macros that control how the compiled expatbehaves:</p><dl><dt><b>XML_UNICODE</b></dt><dd>Use UTF-16 internally and pass strings to application using UTF-16instead of UTF-8. This changes the type definition of <code>XML_Char</code>,which would otherwise be defined as <code>char</code>.</dd><br><br><dt><b>XML_UNICODE_WCHAR_T</b></dt><dd>Use UTF-16 internally as declared as <code>wchar_t</code> from<code>&lt;stddef.h&gt;</code>.and pass strings to application this way. This sets XML_UNICODE if itwasn't already set. If XML_UNICODE is set but not XML_UNICODE_WCHAR_T,then the UTF-16 is stored as unsigned short.</dd><br><br><dt><b>XML_DTD</b></dt><dd>Include code to parse external DTD.</dd><br><br><dt><b>XML_NS</b></dt><dd>Do lexical checking of namespaces</dd><br><br><dt><b>XML_BYTE_ORDER</b></dt><dd>Set this to "12" for little-endian machines (machines that have the leastsignificant byte first) and to "21" for big-endian (most significant bytefirst.)</dd><br><br><dt><b>XML_MIN_SIZE</b></dt><dd>Makes a parser that's smaller but that, in general, will run slower.</dd></dl><p>If your system doesn't have memmove, but does have bcopy,then you'll want to have a macro that redfines memmove to bcopy. There'sa Makefile macro that does this in the sample Makefile, XP_MM. You'll haveto uncomment its definition in order to have it take effect.</p><h3>Working with Expat</h3><p>As I mentioned in the overview section, the document is fed to theparser a piece at a time. It is completely up to the calling applicationhow much of the document to fit into a piece. The sample program,<a href="/1999/09/expat/src/line.c">line</a> demonstrates this. It passes a line at a timeto the parser and then reports start, end, text, and processing instructionevents. By interactively typing in a document into this program, youmay start to obtain an intuitive feel for how the parser is working.<p>Walking through a document hierarchy with a stream oriented parser willrequire a good stack mechanism in order to keep track of current context.For instance, to answer the simple question,"What element does this text belong to?" requires a stack, since theparser may have descended into other elements that are children of thecurrent one and has encountered this text on the way out.</p><p>The things you're likely to want to keep on a stack are the currentlyopened element and it's attributes. You push this information onto thestack in the start handler and you pop it off in the end handler.</p><p>For some tasks, it is sufficient to just keep information on what thedepth of the stack is (or would be if you had one.) The outline program shownabove presents one example. Another such task would be skipping over acomplete element. When you see the start tag for the element you want toskip, you set a skip flag and record the depth at which the element started.When the end tag handler encounters the same depth, the skipped element hasended and the flag may be cleared. If you follow the convention that theroot element starts at 1, then you can use the same variable for skip flagand skip depth.</p><p><!--<div class="eg">--><pre>voidinit_info(Parseinfo *info) {  info->skip = 0;  info->depth = 1;  /* Other initializations here */}  /* End of init_info */voidrawstart(void *data, const char *el, const char **attr) {  Parseinfo *inf = (Parseinfo *) data;  if (! inf->skip) {    if (should_skip(inf, el, attr)) {      inf->skip = inf->depth;    }    else      start(inf, el, attr);     /* This does rest of start handling */  }  inf->depth++;}  /* End of rawstart */voidrawend(void *data, const char *el) {  Parseinfo *inf = (Parseinfo *) data;  inf->depth--;  if (! inf->skip)    end(inf, el);              /* This does rest of end handling */  if (inf->skip == inf->depth)    inf->skip = 0;}  /* End rawend */</pre><!--</div>--></p><p>Notice in the above example the difference in how depth is manipulatedin the start and end handlers. The end tag handler should be the mirrorimage of the start tag handler. This is necessary to properly modelcontainment. Since, in the start tag handler, weincremented depth <em>after</em> the main body of start tag code, then inthe end handler, we need to manipulate it <em>before</em> the main body.If we'd decided to increment it first thing in the start handler, thenwe'd have had to decrement it last thing in the end handler.</p><h3>Communicating between handlers</h3><p>In order to be able to pass information between different handlerswithout using globals, you'll need to define a data structure to holdthe shared variables. You can then tell expat (with the XML_SetUserDatafunction) to pass a pointer to thisstructure to the handlers. This is typically the first argument receivedby most handlers.</p><h3>Namespace Processing</h3><p>When the parser is created using the <code>XML_ParserCreateNS</code>,function, expat performs namespace processing. Under namespace processing,expat consumes <code>xmlns</code> and <code>xmlns:...</code> attributes,which declare namespaces for the scope of the element in which theyoccur. This means that your start handler will not see these attributes.Your application can still be informed of these declarations by settingnamespace declaration handlers with<a href="/pub/a/1999/09/expat/reference.html#namespace_decl"><code>XML_SetNamespaceDeclHandler</code></a>.</p><p>Element type and attribute names that belong to a given namespace arepassed to the appropriate handler in expanded form. This expanded formis a concatenation of the namespace URI, the separator character (whichis the 2nd argument to <code>XML_ParserCreateNS</code>), and the localname (i.e. the part after the colon). Names with undeclared prefixes arepassed through to the handlers unchanged, with the prefix and colon stillattached. Unprefixed attribute names are never expanded, and unprefixedelement names are only expanded when they are in the scope of a defaultnamespace.</p><p>You can set handlers for the start of a namespace declaration and forthe end of a scope of a declaration with the<code>XML_SetNamespaceDeclHandler</code> function.The StartNamespaceDeclHandler is called prior to the start tag handlerand the EndNamespaceDeclHandler is called before the corresponding end tagthat ends the namespace's scope.The namespace start handler gets passed the prefix and URI for the namespace.For a default namespace declaration (xmlns='...'), the prefix will be null.The URI will be null for the case where the default namespace is being unset.The namespace end handler just gets the prefix for the closing scope.</p><p>These handlers are called for each declaration. So if, for instance, astart tag had three namespace declarations, then the StartNamespaceDeclHandlerwould be called three times before the start tag handler is called, once foreach declaration.</p><p>The <a href="/1999/09/expat/src/namespace.c">namespace.c</a> example demonstrates theuse of these features. Like outline.c, it produces an outline, butin addition it annotates when a namespace scope starts and when it ends.This example also demonstrates use of application user data.</p><h3>Character Encodings</h3><p>While XML is based on Unicode, and every XML processor is required torecognized UTF-8 and UTF-16 (1 and 2 byte encodings of Unicode), otherencodings may be declared in XML documents or entities. For the maindocument, an XML declaration may contain an encoding declaration:<pre>&lt;?xml version="1.0" encoding="ISO-8859-2"?&gt;</pre></p><p>External parsed entities may begin with a text declaration, whichlooks like an XML declaration with just an encoding declaration:<pre>&lt;?xml encoding="Big5"?&gt;</pre></p><p>With expat, you may also specify an encoding at the time of creating aparser. This is useful when the encoding information may come from a sourceoutside the document itself (like a higher level protocol.)</p><p><a name="builtin_encodings"></a>There are four built-in encodings in expat:<ul><li>UTF-8<li>UTF-16<li>ISO-8859-1<li>US-ASCII</ul></p><p>Anything else discovered in an encoding declaration or in theprotocol encoding specified in the parser constructor, triggers a callto the <code>UnknownEncodingHandler</code>. This handler gets passedthe encoding name and a pointer to an <code>XML_Encoding</code> datastructure. Your handler must fill in this structure and return 1 if it knows how to deal with the encoding. Otherwise the handler shouldreturn 0.The handler also gets passed a pointer to anoptional application data structure that you may indicate when you setthe handler.</p><p>Expat places restrictions on character encodings that it can supportby filling in the <code>XML_Encoding</code> structure.include file:</p><ol><li>Every ASCII character that can appear in a well-formed XML documentmust be represented by a single byte, and that byte must correspond toit's ASCII encoding (except for the characters $@\^'{}~)</li><br><br><li>Characters must be encoded in 4 bytes or less.</li><br><br><li>All characters encoded must have Unicode scalar values less than orequal to 65535 (0xFFFF)<em>This does not apply to the built-in supportfor UTF-16 and UTF-8</em></li><br><br><li>No character may be encoded by more that one distinct sequence ofbytes</li></ol><p><code>XML_Encoding</code> contains an array of integers that correspondto the 1st byte of an encoding sequence. If the value in the array for abyte is zero or positive, then the byte is a single byte encoding thatencodes the Unicode scalar value contained in the array. A -1 in this arrayindicates a malformed byte. If the value is-2, -3, or -4, then the byte is the beginning of a 2, 3, or 4 byte sequencerespectively. Multi-byte sequences are sent to the convert function pointedat in the <code>XML_Encoding</code> structure. This function should returnthe Unicode scalar value for the sequence or -1 if the sequence is malformed.</p><p>One pitfall that novice expat users are likely to fall into is thatalthough expat may accept input in various encodings, the strings that itpasses to the handlers are always encoded in UTF-8. Your application isresponsible for any translation of these strings into other encodings.</p><h3>Handling External Entity References</h3><p>Expat does not read or parse external entities directly. Note that anyexternal DTD is a special case of an external entity.If you've set no <code>ExternalEntityRefHandler</code>, then externalentity references are silently ignored. Otherwise, it calls your handler withthe information needed to read and parse the external entity.</p><p>Your handlerisn't actually responsible for parsing the entity, but it is responsiblefor creating a subsidiary parser with<code>XML_ExternalEntityParserCreate</code> that will do the job. This returnsan instance of <code>XML_Parser</code> that has handlers and other datastructures initialized from the parent parser. You may then use<code>XML_Parse</code> or <code>XML_ParseBuffer</code> calls against thisparser.Since external entities my refer to other external entities, your handlershould be prepared to be called recursively.</p><h3>Parsing DTDs</h3><p>In order to parse parameter entities, the macro XML_DTD, must bedefined when expat is compiled. In addition, after creating the parserand before starting the parse, you must call<code>XML_SetParamEntityParsing</code> with one of the following arguments:</p><dl><dt><b>XML_PARAM_ENTITY_PARSING_NEVER</b></dt><dd>Don't parse parameter entities or the external subset</dd><br><br><dt><b>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</b></dt><dd>Parse parameter entites and the external subset unless<code>standalone</code> was set to "yes" in the XML declaration.</dd><br><br><dt><b>XML_PARAM_ENTITY_PARSING_ALWAYS</b></dt><dd>Always parse parameter entities and the external subset</dd></dl><p>In order to read an external subset, you also have to set anexternal entity reference handler as described above.</p><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td><p class="secondary">

<!--CS_PAGE_INDEX--></p></td><td><p class="secondary" align="right"><a href="<!--CS_NEXT_REF-->"> 
</a></p></td></tr></table>



<!--CS_PAGE_BREAK--><p>

<!--CS_PAGE_INDEX--></p>


<html><head><!-- Copyright 1999 Clark Cooper <coopercc@netheaven.com>     All rights reserved.     This is free software. You may distribute or modify according to     the terms of the Perl Artistic license -->  <meta name="author" content="Clark Cooper, coopercc@netheaven.com"><!--<style type="text/css">body {background-color: white}.eg {  padding-left: 1em;  padding-top: .5em;  border: solid thin;  margin: 1em 0;  background-color: tan;  margin-left: 5%;  margin-right: 10%;}.handler {  margin-left: 5%;  margin-right: 5%;  margin-top: 1em;  margin-bottom: 1em;  padding-left: 1em;  padding-top: .5em;  border: groove thin;  background-color: beige;}.handler p {  margin-left: 3%;}.setter {  font-weight: bold;}.signature {  margin-left: -3%;  color: navy;}dt {margin-bottom: 1 em;}</style>--></head><body><h3>Expat Function Reference</h3><table width="170" align="right" border="0" cellpadding="0" cellspacing="0"><tr><td width="170" bgcolor="#006666" colspan="4" valign="middle" align="center"><font face="georgia,Times New Roman" color="#ffffff" size="3"><b>Expat Functions</b></a></font></td></tr><tr><td width="10" valign="top"><img src="/universal/images/blank.gif" width="10" height="1"></td><td width="1" valign="top" bgcolor="#006666"><img src="/universal/images/blank.gif" width="1" height="1"></td><td width="9" valign="top"><img src="/universal/images/blank.gif" width="9" height="1"></td><td width="150" valign="top"><p><div class="sidebar"><a href="#lchar">XML_ErrorString</a><br><a href="#extparsercreate">XML_ExternalEntityParserCreate</a><br><a href="#getbase">XML_GetBase</a><br><a href="#getbuffer">XML_GetBuffer</a><br><a href="#getcurbyteindex">XML_GetCurrentByteIndex</a><br><a href="#getcurcolnum">XML_GetCurrentColumnNumber</a><br><a href="#getcurlinenum">XML_GetCurrentLineNumber</a><br><a href="#geterrorcode">XML_GetErrorCode</a><br><a href="#getspecattrib">XML_GetSpecifiedAttributeCount</a><br><a href="#getuserdata">XML_GetUserData</a><br><a href="#parse">XML_Parse</a><br><a href="#parsebuffer">XML_ParseBuffer</a><br><a href="#parsercreate">XML_ParserCreate</a><br><a href="#parsercreatens">XML_ParserCreateNS</a><br><a href="#parserfree">XML_ParserFree</a><br><a href="#setbase">XML_SetBase</a><br><a href="#cdatahandler">XML_SetCdataSectionHandler</a><br><a href="#chardatahandler">XML_SetCharacterDataHandler</a><br><a href="#commenthandler">XML_SetCommentHandler</a><br><a href="#setdefhandler">XML_SetDefaultHandler</a><br><a href="#defhandlerex">XML_SetDefaultHandlerExpand</a><br><a href="#elementhandler">XML_SetElementHandler</a><br><a href="#extrefhandler">XML_SetExternalEntityRefHandler</a><br><a href="#setencoding">XML_SetEncoding</a><br><a href="#namespace_decl">XML_SetNamespaceDeclHandler</a><br><a href="#setnotation">XML_SetNotationDeclHandler</a><br><a href="#setnotstand">XML_SetNotStandaloneHandler</a><br><a href="#set param">XML_SetParamEntityParsing</a><br><a href="#procinsthandler">XML_SetProcessingInstructionHandler</a><br><a href="#setunknown">XML_SetUnknownEncodingHandler</a><br><a href="#setunparsed">XML_SetUnparsedEntityDeclHandler</a><br><a href="#setuserdata">XML_SetUserData</a><br><a href="#useparser">XML_UseParserAsHandlerArg</a><br></div></p></td></tr></table><h3>Parser Creation</h3><a name="parsercreate"><h4 class="function">XML_ParserCreate</h4></a><code>XML_Parser XML_ParserCreate(const XML_Char*encoding)</code><br>Construct a new parser. If encoding is non-null, it specifies acharacter encoding to use for the document. This overrides the documentencoding declaration. There are four built-in encodings:<ul><li>US-ASCII<li>UTF-8<li>UTF-16<li>ISO-8859-1</ul>Any other value will invoke a call to the UnknownEncodingHandler.<hr size="1" noshade><a name="parsercreatens"><h4 class="function">XML_ParserCreateNS</h4></a><code>XML_Parser XML_ParserCreateNS(const XML_Char*encoding, XML_Char sep)</code><br>Constructs a new parser that has namespace processing in effect. Namespaceexpanded element names and attribute names are returned as a concatenationof the namespace URI, <em>sep</em>, and the local part of the name. Thismeans that you should pick a character for <em>sep</em> that can't bepart of a legal URI.<hr size="1" noshade><a name="extparsercreate"><h4 class="function">XML_ExternalEntityParserCreate</h4></a><code>XML_Parser XML_ExternalEntityParserCreate(XML_Parser p, const XML_Char *context, const XML_Char *encoding)</code><br>Construct a new XML_Parser object for parsing an external generalentity. Context is the context argument passed in a call to aExternalEntityRefHandler. Other state information such as handlers, user data,namespace processing is inherited from the parser passed as the 1stargument. So you shouldn't need to call any of the behavior changingfunctions on this parser (unless you want it to act differently than theparent parser.)<hr size="1" noshade><a name="parserfree"><h4 class="function">XML_ParserFree</h4></a><code>void XML_ParserFree(XML_Parser p)</code><br>Free memory used by the parser. Your application is responsible forfreeing any memory associated with <a href="#setuserdata">UserData</a>.<h3>Parsing</h3><a name="parse"><h4 class="function">XML_Parse</h4></a><code>int XML_Parse(XML_Parser p, const char *s, int len, int isFinal) </code><br>Parse some more of the document. The string <code>s</code> is a buffercontaining part (or perhaps all) of the document. The number of bytes of sthat are part of the document is indicated by <code>len</code>. This meansthat <code>s</code> doesn't have to be null terminated. It also means thatif <code>len</code> is larger than the number of bytes in the block ofmemory that <code>s</code> points at, then a memory fault is likely. The<code>isFinal</code> parameter informs the parser that this is the lastpiece of the document. Frequently, the last piece is empty (i.e.<code>len</code> is zero.)If a parse error occurred, it returns 0. Otherwise it returns a non-zerovalue.<hr size="1" noshade><a name="parsebuffer"><h4 class="function">XML_ParseBuffer</h4></a><code>int XML_ParseBuffer(XML_Parser p, int len, int isFinal)</code><br>This is just like XML_Parse, except in this case expat provides the buffer.By obtaining the buffer from expat with the <code>XML_GetBuffer</code>function, the application can avoid double copying of the input.<hr size="1" noshade><a name="getbuffer"><h4 class="function">XML_GetBuffer</h4></a><code>void *XML_GetBuffer(XML_Parser p, int len)</code><br>Obtain a buffer of size <code>len</code> to read a piece of the documentinto. A NULL value is returned if expat can't allocate enough memory forthis buffer. This has to be called prior to every call to<code>XML_ParseBuffer</code>. A typical use would look like this:<div id="eg"><pre>for (;;) {  int bytes_read;  void *buff = XML_GetBuffer(p, BUFF_SIZE);  if (buff == NULL) {    /* handle error */  }  bytes_read = read(docfd, buff, BUFF_SIZE);  if (bytes_read < 0) {    /* handle error */  }  if (! XML_ParseBuffer(p, bytes_read, bytes_read == 0)) {    /* handle parse error */  }  if (bytes_read == 0)    break;}  </pre></div><hr size="1" noshade><h3>Handler Setting</h3><p>Although handlers are typically set prior to parsing and left alone, anapplication may choose to set or change the handler for a parsing eventwhile the parse is in progress. For instance, your application may chooseto ignore all text not descended from a <code>para</code> element. Oneway it could do this is to set the character handler when a para start tagis seen, and unset it for the corresponding end tag.<p>A handler may be <em>unset</em> by providing a NULL pointer to theappropriate handler setter. None of the handler setting functions havea return value.<p>Your handlers will be receiving strings in arrays of type<code>XML_Char</code>. This type is defined in xmlparse.h and is conditionalupon the setting of either of the XML_UNICODE macros. If neither of theseis set, then <code>XML_Char</code> contains characters encoding UTF-8.Otherwise you'll be receiving UTF-16 in the form of either<code>unsigned short</code> or <code>wchar_t</code> characters.<p>Note that you'll receive them in this form independent of the originalencoding of the document. Elsewhere in this document, I may make this pointby simply referring to UTF-8.<hr size="1" noshade><div class="handler"><div class="setter"><a name="elementhandler"><h4 class="function">XML_SetElementHandler</h4></a><pre>XML_SetElementHandler(XML_Parser p,                      XML_StartElementHandler start,                      XML_EndElementHandler end);</pre></div><div class="signature"><pre>typedef void(*XML_StartElementHandler)(void *userData,                           const XML_Char *name,                           const XML_Char **atts);</pre></div><div class="signature"><pre>typedef void(*XML_EndElementHandler)(void *userData,                         const XML_Char *name);</pre></div><p>Set handlers for start and end tags. Attributes are passed to the starthandler as a pointer to a vector of char pointers. Each attribute seen ina start (or empty) tag occupies 2 consecutive places in this vector: theattribute name followed by the attribute value. These pairs are terminatedby a null pointer.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="chardatahandler"><h4 class="function">XML_SetCharacterDataHandler</h4></a><pre>XML_SetCharacterDataHandler(XML_Parser p,                            XML_CharacterDataHandler charhndl)</pre></div><div class="signature"><pre>typedef void(*XML_CharacterDataHandler)(void *userData,                            const XML_Char *s,                            int len);</pre></div><p>Set a text handler. The string your handler receivesis <em>NOT zero terminated</em>. You have to use the length argumentto deal with the end of the string. A single block of contiguous textfree of markup may still result in a sequence of calls to this handler.In other words, if you're searching for a pattern in the text, it maybe split across calls to this handler.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="procinsthandler"><h4 class="function">XML_SetProcessingInstructionHandler</h4></a><pre>XML_SetProcessingInstructionHandler(XML_Parser p,                                    XML_ProcessingInstructionHandler proc)</pre></div><div class="signature"><pre>typedef void(*XML_ProcessingInstructionHandler)(void *userData,                                    const XML_Char *target,                                    const XML_Char *data);</pre></div><p>Set a handler for processing instructions. The target is the first wordin the processing instruction. The data is the rest of the characters init after skipping all whitespace after the initial word.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="commenthandler"><h4 class="function">XML_SetCommentHandler</h4></a><pre>XML_SetCommentHandler (XML_Parser p,                      XML_CommentHandler cmnt)</pre></div><div class="signature"><pre>typedef void(*XML_CommentHandler)(void *userData,                      const XML_Char *data);</pre></div><p>Set a handler for comments. The data is all text inside the commentdelimiters.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="cdatahandler"><h4 class="function">XML_SetCdataSectionHandler</h4></a><pre>XML_SetCdataSectionHandler(XML_Parser p,                           XML_StartCdataSectionHandler start,                           XML_EndCdataSectionHandler end)</pre></div><div class="signature"><pre>typedef void(*XML_StartCdataSectionHandler)(void *userData);</pre></div><div class="signature"><pre>typedef void(*XML_EndCdataSectionHandler)(void *userData);</pre></div><p>Sets handlers that get called at the beginning and end of aCDATA section.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="setdefhandler"><h4 class="function">XML_SetDefaultHandler</h4></a><pre>XML_SetDefaultHandler(XML_Parser p,                      XML_DefaultHandler hndl)</pre></div><div class="signature"><pre>typedef void(*XML_DefaultHandler)(void *userData,                      const XML_Char *s,                      int len);</pre></div><p>Sets a handler for any characters in the document which wouldn'totherwise be handled. This includes both data for which no handlers can beset (like some kinds of DTD declarations) and data which could be reportedbut which currently has no handler set. Note that a contiguous piece ofdata that is destined to be reported to the default handler may actuallybe reported over several calls to the handler. Setting the handler withthis call has the side effect of turning off expansion of referencesto internally defined general entities. Instead these references arepassed to the default handler.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="defhandlerex"><h4 class="function">XML_SetDefaultHandlerExpand</h4></a><pre>XML_SetDefaultHandlerExpand(XML_Parser p,                            XML_DefaultHandler hndl)</pre></div><p>This sets a default handler, but doesn't affect expansion of internalentity references.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="extrefhandler"><h4 class="function">XML_SetExternalEntityRefHandler</h4></a><pre>XML_SetExternalEntityRefHandler(XML_Parser p,                                XML_ExternalEntityRefHandler hndl)</pre></div><div class="signature"><pre>typedef int(*XML_ExternalEntityRefHandler)(XML_Parser parser,                                const XML_Char *context,                                const XML_Char *base,                                const XML_Char *systemId,                                const XML_Char *publicId);</pre></div><p>Set an external entity reference handler. This handler is alsocalled for processing an external DTD subset if parameter entity parsingis in effect. (<a href="#set param">See <code>XML_SetParamEntityParsing</code></a>)<p>The base parameter is the base to use for relative system identifiers.It is set by <a href="#setbase">XML_SetBase</a> and may be null. Thepublic id parameter is the public id given in the entity declaration andmay be null. The system id is the system identifier specified in the entitydeclaration and is never null.<p>There are a couple of ways in which this handler differs from others.First, this handler returns an integer. A non-zero value should be returnedfor successful handling of the external entity reference. Returning a zeroindicates failure, and causes the calling parser to returnan XML_ERROR_EXTERNAL_ENTITY_HANDLING error.<p>Second, instead of having userData as its first argument, it receives theparser that encountered the entity reference. This, along with the contextparameter, may be used as arguments to a call to<a href="#extparsercreate">XML_ExternalEntityParserCreate</a>. Using thereturned parser, the body of the external entity can be recursivelyparsed.<p>Since this handler may be called recursively, it should not be savinginformation into global or static variables.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="setunknown"><h4 class="function">XML_SetUnknownEncodingHandler</h4></a><pre>XML_SetUnknownEncodingHandler(XML_Parser p,                              XML_UnknownEncodingHandler enchandler,         void *encodingHandlerData)</pre></div><div class="signature"><pre>typedef int(*XML_UnknownEncodingHandler)(void *encodingHandlerData,                              const XML_Char *name,                              XML_Encoding *info);</pre></div><p>Set a handler to deal with encodings other than the<a href="#builtin_encodings">built in</a> set. If the handler knows howto deal with an encoding with the given name, it should fill in the infodata structure and return 1. Otherwise it should return 0.<pre>typedef struct {  int map[256];  void *data;  int (*convert)(void *data, const char *s);  void (*release)(void *data);} XML_Encoding;</pre><p>The map array contains information for every possible possible leadingbyte in a byte sequence. If the corresponding value is >= 0, then it'sa single byte sequence and the byte encodes that Unicode value. If thevalue is -1, then that byte is invalid as the initial byte in a sequence.If the value is -n, where n is an integer > 1, then n is the number ofbytes in the sequence and the actual conversion is accomplished by acall to the function pointed at by convert. This function may return -1if the sequence itself is invalid. The convert pointer may be null ifthere are only single byte encodings. The data parameter passed to the convertfunction is the data pointer from XML_Encoding. The string s is <em>NOT</em>null terminated and points at the sequence of bytes to be converted.<p>The function pointed at by release is called by the parser when it isfinished with the encoding. It may be null.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="namespace_decl"><h4 class="function">XML_SetNamespaceDeclHandler</h4></a><pre>XML_SetNamespaceDeclHandler(XML_Parser p,                            XML_StartNamespaceDeclHandler start,                            XML_EndNamespaceDeclHandler end)</pre></div><div class="signature"><pre>typedef void(*XML_StartNamespaceDeclHandler)(void *userData,                                 const XML_Char *prefix,                                 const XML_Char *uri);</pre></div><div class="signature"><pre>typedef void(*XML_EndNamespaceDeclHandler)(void *userData,                               const XML_Char *prefix);</pre></div><p>Set handlers for namespace declarations. Namespace declarations occurinside start tags. But the namespace declaration start handler is called beforethe start tag handler for each namespace declared in that start tag. Thecorresponding namespace end handler is called after the end tag for theelement the namespace is associated with.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="setunparsed"><h4 class="function">XML_SetUnparsedEntityDeclHandler</h4></a><pre>XML_SetUnparsedEntityDeclHandler(XML_Parser p,                                 XML_UnparsedEntityDeclHandler h)</pre></div><div class="signature"><pre>typedef void(*XML_UnparsedEntityDeclHandler)(void *userData,                                 const XML_Char *entityName,                                 const XML_Char *base,                                 const XML_Char *systemId,                                 const XML_Char *publicId,                                 const XML_Char *notationName);</pre></div><p>Set a handler that receives declarations of unparsed entities. Theseare entity declarations that have a notation (NDATA) field:<div id="eg"><pre>&lt;!ENTITY logo SYSTEM "images/logo.gif" NDATA gif&gt;</pre></div><p>So for this example, the entityName would be "logo", the systemIdwould be "images/logo.gif" and notationName would be "gif". For thisexample the publicId parameter is null. The base parameter would bewhatever has been set with <code><a href="#setbase">XML_SetBase</code></a>.If not set, it would be null.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="setnotation"><h4 class="function">XML_SetNotationDeclHandler</h4></a><pre>XML_SetNotationDeclHandler(XML_Parser p,                           XML_NotationDeclHandler h)</pre></div><div class="signature"><pre>typedef void(*XML_NotationDeclHandler)(void *userData,                           const XML_Char *notationName,                           const XML_Char *base,                           const XML_Char *systemId,                           const XML_Char *publicId);</pre></div><p>Set a handler that receives notation declarations.</div><hr size="1" noshade><div class="handler"><div class="setter"><a name="setnotstand"><h4 class="function">XML_SetNotStandaloneHandler</h4></a><pre>XML_SetNotStandaloneHandler(XML_Parser p,                            XML_NotStandaloneHandler h)</pre></div><div class="signature"><pre>typedef int (*XML_NotStandaloneHandler)(void *userData);</pre></div><p>Set a handler that is called if the document is not "standalone".This happens when there is an external subset or a reference to a parameterentity, but does not have standalone set to "yes" in an XML declaration.If this handler returns 0, then the parser will throw anXML_ERROR_NOT_STANDALONE error.</div><hr size="1" noshade><h3>Parse position and error reporting functions</h3><p>These are the functions you'll want to call when the parse functionsreturn 0, although the position reporting functions are useful outsideof errors. The position reported is that of the first of the sequenceof characters that generated the current event (or the error that causedthe parse functions to return 0.)</p><hr size="1" noshade><a name="geterrorcode"><h4 class="function">XML_GetErrorCode</h4></a><code>enum XML_Error XML_GetErrorCode(XML_Parser p)</code><br>Return what type of error has occurred.<br><hr size="1" noshade><a name="lchar"><h4 class="function">XML_ErrorString</h4></a><code>const XML_LChar *XML_ErrorString(int code)</code><br>Return a string describing the error corresponding to code.The code should be one of the enums that can be returned fromXML_GetErrorCode.<br><hr size="1" noshade><a name="getcurbyteindex"><h4 class="function">XML_GetCurrentByteIndex</h4></a><code>long XML_GetCurrentByteIndex(XML_Parser p)</code><br>Return the byte offset of the position.<br><hr size="1" noshade><a name="getcurlinenum"><h4 class="function">XML_GetCurrentLineNumber</h4></a><code>int XML_GetCurrentLineNumber(XML_Parser p)</code><br>Return the line number of the position.<br><hr size="1" noshade><a name="getcurcolnum"><h4 class="function">XML_GetCurrentColumnNumber</h4></a><code>int XML_GetCurrentColumnNumber(XML_Parser p)</code><br>Return the offset, from the beginning of the current line, ofthe position.<br><hr size="1" noshade><h3>Miscellaneous functions</h3><p>The functions in this section either obtain state information from theparser or can be used to dynamically set parser options.</p><hr size="1" noshade><a name="setuserdata"><h4 class="function">XML_SetUserData</h4></a><code>XML_SetUserData(XML_Parser p, void *userData)</code><br>This sets the user data pointer that gets passed to handlers.<hr size="1" noshade><a name="getuserdata"><h4 class="function">XML_GetUserData</h4></a><code>void * XML_GetUserData(XML_Parser p)</code><br>This returns the user data pointer that gets passed to handlers.It is actually implemented as a macro.<hr size="1" noshade><a name="useparser"><h4 class="function">XML_UseParserAsHandlerArg</h4></a><code>void XML_UseParserAsHandlerArg(XML_Parser p)</code><br>After this is called, handlers receive the parser in theuserData argument. The userData information can still be obtained usingthe XML_GetUserData function above.<hr size="1" noshade><a name="setbase"><h4 class="function">XML_SetBase</h4></a><code>int XML_SetBase(XML_Parser p, const XML_Char *base)</code><br>Set the base to be used for resolving relative URIs in system identifiers.The return value is 0 if there's no memory to store base, otherwise it'snon-zero.<hr size="1" noshade><a name="getbase"><h4 class="function">XML_GetBase</h4></a><code>const XML_Char * XML_GetBase(XML_Parser p)</code><br>Return the base for resolving relative URIs.<hr size="1" noshade><a name="getspecattrib"><h4 class="function">XML_GetSpecifiedAttributeCount</h4></a><code>int XML_GetSpecifiedAttributeCount(XML_Parser p)</code><br>When attributes are reported to the start handler in the atts vector,attributes that were explicitly set in the element occur before anyattributes that receive their value from default information in anATTLIST declaration. This function returns the number of attributes thatwere explicitly set, thus giving the offset of the first attribute setdue to defaults. It supplies information for the last call to a starthandler. If you're in a start handler, then that means the current call.<hr size="1" noshade><a name="setencoding"><h4 class="function">XML_SetEncoding</h4></a><code>int XML_SetEncoding(XML_Parser p, const XML_Char *encoding)</code><br>Set the encoding to be used by the parser. It is equivalent topassing a non-null encoding argument to the parser creation functions.It must not be called after XML_Parser or XML_ParseBuffer have beencalled on the parser.<hr size="1" noshade><a name="set param"><h4 class="function">XML_SetParamEntityParsing</h4></a><code>int XML_SetParamEntityParsing(XML_Parser p, enum XML_ParamEntityParsing code)</code><br>If the parser wasn't compiled with the XML_DTD macro set, then thisjust returns 0. Otherwise it returns 1 and enables parsing of parameterentities, including the external parameter entity that is the externalDTD subset, according to code. The choices for code are:<ul><li>XML_PARAM_ENTITY_PARSING_NEVER<li>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE<li>XML_PARAM_ENTITY_PARSING_ALWAYS</ul>

<p><font face="verdana,arial,helvetica" size="1"><b>XML.com</b> Copyright &copy; 1998-2006 O'Reilly Media, Inc.</font></p></body>



<!-- ISI_LISTEN_STOP -->





</html>











